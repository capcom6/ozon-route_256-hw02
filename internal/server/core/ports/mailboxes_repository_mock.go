package ports

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

//go:generate minimock -i gitlab.ozon.dev/capcom6/homework-2/internal/server/core/ports.MailboxesRepository -o ./internal/server/core/ports/mailboxes_repository_mock.go -n MailboxesRepositoryMock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"gitlab.ozon.dev/capcom6/homework-2/internal/server/core/domain"
)

// MailboxesRepositoryMock implements MailboxesRepository
type MailboxesRepositoryMock struct {
	t minimock.Tester

	funcCreate          func(ctx context.Context, m domain.Mailbox) (i1 int, err error)
	inspectFuncCreate   func(ctx context.Context, m domain.Mailbox)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mMailboxesRepositoryMockCreate

	funcDelete          func(ctx context.Context, userId string, id int) (err error)
	inspectFuncDelete   func(ctx context.Context, userId string, id int)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mMailboxesRepositoryMockDelete

	funcSelect          func(ctx context.Context, userId string) (ma1 []domain.Mailbox, err error)
	inspectFuncSelect   func(ctx context.Context, userId string)
	afterSelectCounter  uint64
	beforeSelectCounter uint64
	SelectMock          mMailboxesRepositoryMockSelect
}

// NewMailboxesRepositoryMock returns a mock for MailboxesRepository
func NewMailboxesRepositoryMock(t minimock.Tester) *MailboxesRepositoryMock {
	m := &MailboxesRepositoryMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mMailboxesRepositoryMockCreate{mock: m}
	m.CreateMock.callArgs = []*MailboxesRepositoryMockCreateParams{}

	m.DeleteMock = mMailboxesRepositoryMockDelete{mock: m}
	m.DeleteMock.callArgs = []*MailboxesRepositoryMockDeleteParams{}

	m.SelectMock = mMailboxesRepositoryMockSelect{mock: m}
	m.SelectMock.callArgs = []*MailboxesRepositoryMockSelectParams{}

	return m
}

type mMailboxesRepositoryMockCreate struct {
	mock               *MailboxesRepositoryMock
	defaultExpectation *MailboxesRepositoryMockCreateExpectation
	expectations       []*MailboxesRepositoryMockCreateExpectation

	callArgs []*MailboxesRepositoryMockCreateParams
	mutex    sync.RWMutex
}

// MailboxesRepositoryMockCreateExpectation specifies expectation struct of the MailboxesRepository.Create
type MailboxesRepositoryMockCreateExpectation struct {
	mock    *MailboxesRepositoryMock
	params  *MailboxesRepositoryMockCreateParams
	results *MailboxesRepositoryMockCreateResults
	Counter uint64
}

// MailboxesRepositoryMockCreateParams contains parameters of the MailboxesRepository.Create
type MailboxesRepositoryMockCreateParams struct {
	ctx context.Context
	m   domain.Mailbox
}

// MailboxesRepositoryMockCreateResults contains results of the MailboxesRepository.Create
type MailboxesRepositoryMockCreateResults struct {
	i1  int
	err error
}

// Expect sets up expected params for MailboxesRepository.Create
func (mmCreate *mMailboxesRepositoryMockCreate) Expect(ctx context.Context, m domain.Mailbox) *mMailboxesRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("MailboxesRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &MailboxesRepositoryMockCreateExpectation{}
	}

	mmCreate.defaultExpectation.params = &MailboxesRepositoryMockCreateParams{ctx, m}
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the MailboxesRepository.Create
func (mmCreate *mMailboxesRepositoryMockCreate) Inspect(f func(ctx context.Context, m domain.Mailbox)) *mMailboxesRepositoryMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for MailboxesRepositoryMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by MailboxesRepository.Create
func (mmCreate *mMailboxesRepositoryMockCreate) Return(i1 int, err error) *MailboxesRepositoryMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("MailboxesRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &MailboxesRepositoryMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &MailboxesRepositoryMockCreateResults{i1, err}
	return mmCreate.mock
}

//Set uses given function f to mock the MailboxesRepository.Create method
func (mmCreate *mMailboxesRepositoryMockCreate) Set(f func(ctx context.Context, m domain.Mailbox) (i1 int, err error)) *MailboxesRepositoryMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the MailboxesRepository.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the MailboxesRepository.Create method")
	}

	mmCreate.mock.funcCreate = f
	return mmCreate.mock
}

// When sets expectation for the MailboxesRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mMailboxesRepositoryMockCreate) When(ctx context.Context, m domain.Mailbox) *MailboxesRepositoryMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("MailboxesRepositoryMock.Create mock is already set by Set")
	}

	expectation := &MailboxesRepositoryMockCreateExpectation{
		mock:   mmCreate.mock,
		params: &MailboxesRepositoryMockCreateParams{ctx, m},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up MailboxesRepository.Create return parameters for the expectation previously defined by the When method
func (e *MailboxesRepositoryMockCreateExpectation) Then(i1 int, err error) *MailboxesRepositoryMock {
	e.results = &MailboxesRepositoryMockCreateResults{i1, err}
	return e.mock
}

// Create implements MailboxesRepository
func (mmCreate *MailboxesRepositoryMock) Create(ctx context.Context, m domain.Mailbox) (i1 int, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, m)
	}

	mm_params := &MailboxesRepositoryMockCreateParams{ctx, m}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_got := MailboxesRepositoryMockCreateParams{ctx, m}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("MailboxesRepositoryMock.Create got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the MailboxesRepositoryMock.Create")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, m)
	}
	mmCreate.t.Fatalf("Unexpected call to MailboxesRepositoryMock.Create. %v %v", ctx, m)
	return
}

// CreateAfterCounter returns a count of finished MailboxesRepositoryMock.Create invocations
func (mmCreate *MailboxesRepositoryMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of MailboxesRepositoryMock.Create invocations
func (mmCreate *MailboxesRepositoryMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to MailboxesRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mMailboxesRepositoryMockCreate) Calls() []*MailboxesRepositoryMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*MailboxesRepositoryMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *MailboxesRepositoryMock) MinimockCreateDone() bool {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateInspect logs each unmet expectation
func (m *MailboxesRepositoryMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MailboxesRepositoryMock.Create with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MailboxesRepositoryMock.Create")
		} else {
			m.t.Errorf("Expected call to MailboxesRepositoryMock.Create with params: %#v", *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && mm_atomic.LoadUint64(&m.afterCreateCounter) < 1 {
		m.t.Error("Expected call to MailboxesRepositoryMock.Create")
	}
}

type mMailboxesRepositoryMockDelete struct {
	mock               *MailboxesRepositoryMock
	defaultExpectation *MailboxesRepositoryMockDeleteExpectation
	expectations       []*MailboxesRepositoryMockDeleteExpectation

	callArgs []*MailboxesRepositoryMockDeleteParams
	mutex    sync.RWMutex
}

// MailboxesRepositoryMockDeleteExpectation specifies expectation struct of the MailboxesRepository.Delete
type MailboxesRepositoryMockDeleteExpectation struct {
	mock    *MailboxesRepositoryMock
	params  *MailboxesRepositoryMockDeleteParams
	results *MailboxesRepositoryMockDeleteResults
	Counter uint64
}

// MailboxesRepositoryMockDeleteParams contains parameters of the MailboxesRepository.Delete
type MailboxesRepositoryMockDeleteParams struct {
	ctx    context.Context
	userId string
	id     int
}

// MailboxesRepositoryMockDeleteResults contains results of the MailboxesRepository.Delete
type MailboxesRepositoryMockDeleteResults struct {
	err error
}

// Expect sets up expected params for MailboxesRepository.Delete
func (mmDelete *mMailboxesRepositoryMockDelete) Expect(ctx context.Context, userId string, id int) *mMailboxesRepositoryMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("MailboxesRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &MailboxesRepositoryMockDeleteExpectation{}
	}

	mmDelete.defaultExpectation.params = &MailboxesRepositoryMockDeleteParams{ctx, userId, id}
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the MailboxesRepository.Delete
func (mmDelete *mMailboxesRepositoryMockDelete) Inspect(f func(ctx context.Context, userId string, id int)) *mMailboxesRepositoryMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for MailboxesRepositoryMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by MailboxesRepository.Delete
func (mmDelete *mMailboxesRepositoryMockDelete) Return(err error) *MailboxesRepositoryMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("MailboxesRepositoryMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &MailboxesRepositoryMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &MailboxesRepositoryMockDeleteResults{err}
	return mmDelete.mock
}

//Set uses given function f to mock the MailboxesRepository.Delete method
func (mmDelete *mMailboxesRepositoryMockDelete) Set(f func(ctx context.Context, userId string, id int) (err error)) *MailboxesRepositoryMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the MailboxesRepository.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the MailboxesRepository.Delete method")
	}

	mmDelete.mock.funcDelete = f
	return mmDelete.mock
}

// When sets expectation for the MailboxesRepository.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mMailboxesRepositoryMockDelete) When(ctx context.Context, userId string, id int) *MailboxesRepositoryMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("MailboxesRepositoryMock.Delete mock is already set by Set")
	}

	expectation := &MailboxesRepositoryMockDeleteExpectation{
		mock:   mmDelete.mock,
		params: &MailboxesRepositoryMockDeleteParams{ctx, userId, id},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up MailboxesRepository.Delete return parameters for the expectation previously defined by the When method
func (e *MailboxesRepositoryMockDeleteExpectation) Then(err error) *MailboxesRepositoryMock {
	e.results = &MailboxesRepositoryMockDeleteResults{err}
	return e.mock
}

// Delete implements MailboxesRepository
func (mmDelete *MailboxesRepositoryMock) Delete(ctx context.Context, userId string, id int) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, userId, id)
	}

	mm_params := &MailboxesRepositoryMockDeleteParams{ctx, userId, id}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_got := MailboxesRepositoryMockDeleteParams{ctx, userId, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("MailboxesRepositoryMock.Delete got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the MailboxesRepositoryMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, userId, id)
	}
	mmDelete.t.Fatalf("Unexpected call to MailboxesRepositoryMock.Delete. %v %v %v", ctx, userId, id)
	return
}

// DeleteAfterCounter returns a count of finished MailboxesRepositoryMock.Delete invocations
func (mmDelete *MailboxesRepositoryMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of MailboxesRepositoryMock.Delete invocations
func (mmDelete *MailboxesRepositoryMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to MailboxesRepositoryMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mMailboxesRepositoryMockDelete) Calls() []*MailboxesRepositoryMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*MailboxesRepositoryMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *MailboxesRepositoryMock) MinimockDeleteDone() bool {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteInspect logs each unmet expectation
func (m *MailboxesRepositoryMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MailboxesRepositoryMock.Delete with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MailboxesRepositoryMock.Delete")
		} else {
			m.t.Errorf("Expected call to MailboxesRepositoryMock.Delete with params: %#v", *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		m.t.Error("Expected call to MailboxesRepositoryMock.Delete")
	}
}

type mMailboxesRepositoryMockSelect struct {
	mock               *MailboxesRepositoryMock
	defaultExpectation *MailboxesRepositoryMockSelectExpectation
	expectations       []*MailboxesRepositoryMockSelectExpectation

	callArgs []*MailboxesRepositoryMockSelectParams
	mutex    sync.RWMutex
}

// MailboxesRepositoryMockSelectExpectation specifies expectation struct of the MailboxesRepository.Select
type MailboxesRepositoryMockSelectExpectation struct {
	mock    *MailboxesRepositoryMock
	params  *MailboxesRepositoryMockSelectParams
	results *MailboxesRepositoryMockSelectResults
	Counter uint64
}

// MailboxesRepositoryMockSelectParams contains parameters of the MailboxesRepository.Select
type MailboxesRepositoryMockSelectParams struct {
	ctx    context.Context
	userId string
}

// MailboxesRepositoryMockSelectResults contains results of the MailboxesRepository.Select
type MailboxesRepositoryMockSelectResults struct {
	ma1 []domain.Mailbox
	err error
}

// Expect sets up expected params for MailboxesRepository.Select
func (mmSelect *mMailboxesRepositoryMockSelect) Expect(ctx context.Context, userId string) *mMailboxesRepositoryMockSelect {
	if mmSelect.mock.funcSelect != nil {
		mmSelect.mock.t.Fatalf("MailboxesRepositoryMock.Select mock is already set by Set")
	}

	if mmSelect.defaultExpectation == nil {
		mmSelect.defaultExpectation = &MailboxesRepositoryMockSelectExpectation{}
	}

	mmSelect.defaultExpectation.params = &MailboxesRepositoryMockSelectParams{ctx, userId}
	for _, e := range mmSelect.expectations {
		if minimock.Equal(e.params, mmSelect.defaultExpectation.params) {
			mmSelect.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSelect.defaultExpectation.params)
		}
	}

	return mmSelect
}

// Inspect accepts an inspector function that has same arguments as the MailboxesRepository.Select
func (mmSelect *mMailboxesRepositoryMockSelect) Inspect(f func(ctx context.Context, userId string)) *mMailboxesRepositoryMockSelect {
	if mmSelect.mock.inspectFuncSelect != nil {
		mmSelect.mock.t.Fatalf("Inspect function is already set for MailboxesRepositoryMock.Select")
	}

	mmSelect.mock.inspectFuncSelect = f

	return mmSelect
}

// Return sets up results that will be returned by MailboxesRepository.Select
func (mmSelect *mMailboxesRepositoryMockSelect) Return(ma1 []domain.Mailbox, err error) *MailboxesRepositoryMock {
	if mmSelect.mock.funcSelect != nil {
		mmSelect.mock.t.Fatalf("MailboxesRepositoryMock.Select mock is already set by Set")
	}

	if mmSelect.defaultExpectation == nil {
		mmSelect.defaultExpectation = &MailboxesRepositoryMockSelectExpectation{mock: mmSelect.mock}
	}
	mmSelect.defaultExpectation.results = &MailboxesRepositoryMockSelectResults{ma1, err}
	return mmSelect.mock
}

//Set uses given function f to mock the MailboxesRepository.Select method
func (mmSelect *mMailboxesRepositoryMockSelect) Set(f func(ctx context.Context, userId string) (ma1 []domain.Mailbox, err error)) *MailboxesRepositoryMock {
	if mmSelect.defaultExpectation != nil {
		mmSelect.mock.t.Fatalf("Default expectation is already set for the MailboxesRepository.Select method")
	}

	if len(mmSelect.expectations) > 0 {
		mmSelect.mock.t.Fatalf("Some expectations are already set for the MailboxesRepository.Select method")
	}

	mmSelect.mock.funcSelect = f
	return mmSelect.mock
}

// When sets expectation for the MailboxesRepository.Select which will trigger the result defined by the following
// Then helper
func (mmSelect *mMailboxesRepositoryMockSelect) When(ctx context.Context, userId string) *MailboxesRepositoryMockSelectExpectation {
	if mmSelect.mock.funcSelect != nil {
		mmSelect.mock.t.Fatalf("MailboxesRepositoryMock.Select mock is already set by Set")
	}

	expectation := &MailboxesRepositoryMockSelectExpectation{
		mock:   mmSelect.mock,
		params: &MailboxesRepositoryMockSelectParams{ctx, userId},
	}
	mmSelect.expectations = append(mmSelect.expectations, expectation)
	return expectation
}

// Then sets up MailboxesRepository.Select return parameters for the expectation previously defined by the When method
func (e *MailboxesRepositoryMockSelectExpectation) Then(ma1 []domain.Mailbox, err error) *MailboxesRepositoryMock {
	e.results = &MailboxesRepositoryMockSelectResults{ma1, err}
	return e.mock
}

// Select implements MailboxesRepository
func (mmSelect *MailboxesRepositoryMock) Select(ctx context.Context, userId string) (ma1 []domain.Mailbox, err error) {
	mm_atomic.AddUint64(&mmSelect.beforeSelectCounter, 1)
	defer mm_atomic.AddUint64(&mmSelect.afterSelectCounter, 1)

	if mmSelect.inspectFuncSelect != nil {
		mmSelect.inspectFuncSelect(ctx, userId)
	}

	mm_params := &MailboxesRepositoryMockSelectParams{ctx, userId}

	// Record call args
	mmSelect.SelectMock.mutex.Lock()
	mmSelect.SelectMock.callArgs = append(mmSelect.SelectMock.callArgs, mm_params)
	mmSelect.SelectMock.mutex.Unlock()

	for _, e := range mmSelect.SelectMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ma1, e.results.err
		}
	}

	if mmSelect.SelectMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSelect.SelectMock.defaultExpectation.Counter, 1)
		mm_want := mmSelect.SelectMock.defaultExpectation.params
		mm_got := MailboxesRepositoryMockSelectParams{ctx, userId}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSelect.t.Errorf("MailboxesRepositoryMock.Select got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSelect.SelectMock.defaultExpectation.results
		if mm_results == nil {
			mmSelect.t.Fatal("No results are set for the MailboxesRepositoryMock.Select")
		}
		return (*mm_results).ma1, (*mm_results).err
	}
	if mmSelect.funcSelect != nil {
		return mmSelect.funcSelect(ctx, userId)
	}
	mmSelect.t.Fatalf("Unexpected call to MailboxesRepositoryMock.Select. %v %v", ctx, userId)
	return
}

// SelectAfterCounter returns a count of finished MailboxesRepositoryMock.Select invocations
func (mmSelect *MailboxesRepositoryMock) SelectAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelect.afterSelectCounter)
}

// SelectBeforeCounter returns a count of MailboxesRepositoryMock.Select invocations
func (mmSelect *MailboxesRepositoryMock) SelectBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelect.beforeSelectCounter)
}

// Calls returns a list of arguments used in each call to MailboxesRepositoryMock.Select.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSelect *mMailboxesRepositoryMockSelect) Calls() []*MailboxesRepositoryMockSelectParams {
	mmSelect.mutex.RLock()

	argCopy := make([]*MailboxesRepositoryMockSelectParams, len(mmSelect.callArgs))
	copy(argCopy, mmSelect.callArgs)

	mmSelect.mutex.RUnlock()

	return argCopy
}

// MinimockSelectDone returns true if the count of the Select invocations corresponds
// the number of defined expectations
func (m *MailboxesRepositoryMock) MinimockSelectDone() bool {
	for _, e := range m.SelectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SelectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSelectCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSelect != nil && mm_atomic.LoadUint64(&m.afterSelectCounter) < 1 {
		return false
	}
	return true
}

// MinimockSelectInspect logs each unmet expectation
func (m *MailboxesRepositoryMock) MinimockSelectInspect() {
	for _, e := range m.SelectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to MailboxesRepositoryMock.Select with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SelectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSelectCounter) < 1 {
		if m.SelectMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to MailboxesRepositoryMock.Select")
		} else {
			m.t.Errorf("Expected call to MailboxesRepositoryMock.Select with params: %#v", *m.SelectMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSelect != nil && mm_atomic.LoadUint64(&m.afterSelectCounter) < 1 {
		m.t.Error("Expected call to MailboxesRepositoryMock.Select")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *MailboxesRepositoryMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockCreateInspect()

		m.MinimockDeleteInspect()

		m.MinimockSelectInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *MailboxesRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *MailboxesRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockSelectDone()
}
